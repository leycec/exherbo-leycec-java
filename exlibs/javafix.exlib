# Copyright 2009 Sterling X. Winter <replica@exherbo.org>
# Copyright 2010 Cecil Curry <leycec@gmail.com>
# Distributed under the terms of the GNU General Public License v2

# --------------------( SYNOPSIS                           )--------------------
# This exlib provides core facilities for Java-related exhereses.
#
# This exlib is currently backwards compatible with "java.exlib", its
# historical predecessor.

# ....................{ EXHERES                            }....................
require alternatives multilib
export_exlib_phases pkg_setup \
    src_unpack src_prepare src_configure src_compile src_test src_install

# If true, recursively deletes all class files from "${WORK}" immediately after
# extracting source tarballs. Such class files are often bundled with tarballs
# to avoid the need for user recompilation. Make them suffer; oh, yes.
#
# Defaults to true.
myexparam -b clean_jar_files=true

# If true, recursively deletes all JAR files from "${WORK}" immediately after
# extracting source tarballs. Such JAR files are often bundled with tarballs
# to reduce dependency hell. For us, bundled JAR files only aggravate hell.
#
# Defaults to true.
myexparam -b clean_class_files=true

#FIXME: Implement.
# If true, provides an option 'native' allowing native compilation of Java source
# and bytecode using GCJ. This should only be allowed for packages which have
# been tested to both compile and run natively using GCJ 4.3 or later.
myexparam -b build_native_binaries=false

#FIXME: Implement.
# If true, provides an option 'doc' allowing automatic generation of Javadocs from
# Java source files. This obviously clashes with any existing 'doc' option in your
# exheres/exlib.
myexparam -b build_javadoc=false

# If true, adds "virtual/jdk" and "virtual/jre" to the DEPENDENCIES for this
# exheres/exlib.
myexparam -b virtual_jdk_and_jre_deps=true

# ....................{ CONFIGURATION                      }....................
# Array of Java JDK prefixes. If the following expression is true for at least
# one ${JAVA_RESTRICT_JDK_PREFIX} of this array, then installation fails
# prior to performing any work:
#
#     [[ $(eclectic java-jdk show) = "${JAVA_RESTRICT_JDK_PREFIX}"* ]]
#
# Example for exheres failing under "gcj" or "gij":
#
#     JAVA_RESTRICT_JDK_PREFIXES=( gcj )
#
# As of mid 2010, all Ant exheres should test compilation under "gcj". Many will
# fail! Those that do must set this array, as above.
JAVA_RESTRICT_JDK_PREFIXES=( )

# Find parameters to be passed to the command-line invocation of "find" when
# cleaning JAR files from ${WORK}. Specify this to prevent cleaning of wanted,
# specific JAR files: e.g.,
#
#     JAVA_CLEAN_JAR_FILES_PARAMS=( -not -wholename 'bootstrap/young_lad.jar' )
JAVA_CLEAN_JAR_FILES_PARAMS=( )

# Absolute or relative path under ${WORK} into which external JAR files will
# be symlinked. Though this path is usually "lib" for most exheres, you must
# still explicitly specify it to have symlinking performed for you. Example:
#
#     JAVA_SRC_LIBRARY_DIR="lib"
JAVA_SRC_LIBRARY_DIR=""

# Array of absolute paths to or relative names of external JAR files to be
# symlinked into ${JAVA_SRC_LIBRARY_DIR} during the "src_prepare" phase.
# External JAR files should be buildtime dependencies of this exheres. An
# example mixing both absolute paths to and relative names of external files:
#
#     JAVA_SRC_PREPARE_JARS=( jarjar qdox "/usr/share/asm/asm.jar" )
#
# If filenames are not known until install time, leave this array blank and
# call "javafix_prepare_jar_symlinks" within your "src_prepare" function.
JAVA_SRC_PREPARE_JARS=( )

# Array of absolute paths to or relative names of external JAR files to be
# symlinked into ${JAVA_SRC_LIBRARY_DIR} during the "src_test" phase.
# External JAR files should be test-time dependencies of this exheres. An
# example with slotted dependencies:
#
#     JAVA_SRC_TEST_JARS=( "junit:4" )
#
# If filenames are not known until install time, leave this array blank and
# call "javafix_prepare_jar_symlinks" within your "src_test" function.
JAVA_SRC_TEST_JARS=( )

# Array of absolute paths to text files to be "deversion"-ated. Ant "build.xml"
# files often hardcode references to pre-bundled JAR files with names suffixed
# by a version specifier. This is bad, as this exlib replaces all pre-bundled
# JAR files with externally symlinked JAR files with names NEVER EVER suffixed
# by a version specifier. To resolve the discrepancy, we could do one of two
# ugly hacks:
#
# * Sed affected "build.xml" files, removing JAR filename version specifiers OR
# * Grep affected "build.xml" files for these version specifiers and, when
#   symlinking in external JAR files, add the version specifier for each jar
#   filename to its symlink filename.
#
# The first is easier. And easier is better. So that's what we do. Example
# deversioning two files, "build.xml" and "common-build.xml":
#
#     JAVA_SRC_PREPARE_DEVERSION_FILES=( "${JAVA_BUILD_XML}" "common-build.xml" )
JAVA_SRC_PREPARE_DEVERSION_FILES=( )

# Absolute path or relative path under ${WORK} from which HTML API documentation
# will be installed to "/usr/share/doc/${PNVR}/html/javadoc". This documentation
# must be generated by the ${JAVA_BUILD_XML} file for this exheres, dynamically.
# This is usually a directory named "javadoc" for most exheres, but must be
# explicitly specified to have have installation of these files performed for
# you. Example:
#
#     JAVA_SRC_INSTALL_JAVADOC_DIR="javadoc"
JAVA_SRC_INSTALL_JAVADOC_DIR=""

# Array of absolute paths to this exheres' output JAR files to be installed
# under "$(which_installed_jar_dir_for_this_exheres)", with suffixing versions
# automatically removed from filenames on your behalf. Example:
#
#     JAVA_SRC_INSTALL_JARS=( "dist/${PNV}.jar" "dist/${PNV}-library.jar" )
#
# If filenames are not known until install time, leave this blank and explicitly
# call "javafix_install_jars" within your "src_install".
JAVA_SRC_INSTALL_JARS=( )

# Associative array mapping jar specifier to absolute or relative path under
# ${WORK} having a "MANIFEST.MF" file to be added to the JAR file corresponding
# to that jar specifier. The JAR file will have its "META-INF/MANIFEST.MF" file
# replaced by the specified "MANIFEST.MF" file, and then be installed to its
# appropriate place in the filesystem. This array therefore replaces the
# ${JAVA_SRC_INSTALL_JARS} array for exheres requiring both JAR file
# installation and JAR file "MANIFEST.MF" replacement. Example:
#
#     JAVA_SRC_INSTALL_JARS_WITH_MANIFESTS=(
#         "dist/${PNV}.jar"          "${FILES}/${SLOT}/MANIFEST.MF"
#         "dist/${PNV}-library.jar"  "${FILES}/${SLOT}/MANIFEST-library.MF"
#     )
#
# Note that exheres may define both this and the "${JAVA_SRC_INSTALL_JARS}"
# global, above, in which case this exlib will do the right thing.
#
# If filenames are not known until install time, leave this blank and explicitly
# call "javafix_install_jars_with_manifests" within your "src_install".
JAVA_SRC_INSTALL_JARS_WITH_MANIFESTS=( )

# Add a buildtime dependency on "app-arch/zip" to calling exheres. The
# "javafix_replace_jar_manifest" function implicitly requires this binary. While many
# Java exheres do not call this function, many others do; as this is a common
# dependency of other core exheres, our adding it here does little harm.
DEPENDENCIES+="
    build:
        app-arch/zip
"

# ....................{ EXPARAMS                           }....................
if exparam -b build_native_binaries; then
    MYOPTIONS+="native [[ description = [ Compile Java source/bytecode to native executables ] ]]"
    DEPENDENCIES+="
        build+run:
            native? ( sys-devel/gcc[>=4.3][java] )
    "
    if exparam -b virtual_jdk_and_jre_deps; then
        DEPENDENCIES+="
            build:
                !native? ( virtual/jdk )
            run:
                !native? ( virtual/jre )
        "
    fi
elif exparam -b virtual_jdk_and_jre_deps; then
    DEPENDENCIES+="
        build:
            virtual/jdk
        run:
            virtual/jre
    "
fi

if exparam -b build_javadoc; then
    MYOPTIONS+="doc [[ description = [ Build API documentation from Java source ] ]]"
    DEPENDENCIES+="
        build:
            doc? ( virtual/javadoc )
    "

    # Generate Javadoc to the following directory.
    JAVA_SRC_INSTALL_JAVADOC_DIR="${WORK}/javadoc"
fi

# ....................{ CONSTANTS                          }....................
# This exlib sets these constants on your behalf. Read them; don't write them.
# 
# Scratch that -- don't even read them. If you access these constants in any
# exheres, you're doing something wrong. :)

# Name of the currently selected Java JDK: e.g., "icedtea6", "gcj-jdk". This
# defaults to the empty string here but is set in the "pkg_setup" phase.
JAVA_JDK=

# Version of the currently selected Java JDK: e.g., "1.6", "4.4". This
# defaults to the empty string here but is set in the "pkg_setup" phase.
JAVA_JDK_VERSION=

# Absolute path to the directory having JDK JAR files for the above compiler:
# e.g., "rt.jar", "jce.jar".
JAVA_JRE_LIBRARY_DIR="/usr/$(get_libdir)/jre/lib"

# If non-empty, disable sydbox's network sandboxing. At the moment this is only
# enabled when "gcj" is the currently selected Java compiler. This additionally
# implies that "gij" is the currently selected Java interpreter.
#
# Defaults to empty. See the "java_pkg_setup" function for detail.
JAVA_IS_DISABLING_NETWORK_SANDBOXING=

# If non-empty, call default_src_unpack() to perform automated unpacking of
# downloaded archives. Most exheres want this; those that do not (e.g., Eclipse,
# Eclipse SWT) require sufficiently complex unpacking to warrant their doing it
# themselves. (This is not recommended.)
#
# Defaults to non-empty.
JAVA_IS_UNPACKING_ARCHIVES=1

# Bash glob pattern matching a version of maximum length: e.g., "4.2.24".
JAVA_VERSION_GLOB='+([[:digit:].])*(rc+([[:digit:].]))'

# Bash pattern matching the version suffix commonly appended to JAR filenames.
# This pattern matches conventional versions (e.g., "hamcrest-1.2.jar") and
# unconventional revisioned versions (e.g., "jarjar-1.0rc8.jar"). By design,
# this pattern may also be passed without change to "egrep" or "sed -r".
#
# Don't forget to append a '$' if appropriate!
JAVA_JAR_VERSION_PATTERN='-[[:digit:].]+(rc[[:digit:].]+)?\.jar'

# Bash glob pattern matching the same from within a parameter expansion: e.g.,
#
#    # Prints "harhar.jar".
#    JAR_FILE=harhar-5.62.951.jar && \
#        echo ${JAR_FILE/${JAVA_JAR_VERSION_PARAMETER_PATTERN}/.jar}
JAVA_JAR_VERSION_PARAMETER_PATTERN='%-'"${JAVA_VERSION_GLOB}"'\.jar'

# ....................{ PHASES                             }....................
javafix_pkg_setup() {
    default

    # If ${JAVA_HOME} is not set, then this exheres is probably a JDK that,
    # following installation, will set this. So, don't spit out an error.
    [[ -n "${JAVA_HOME}" ]] && javafix_check_jdk
}

javafix_src_unpack() {
    # Call "default_src_unpack", unless the calling exheres has other plans.
    if [[ -n "${JAVA_IS_UNPACKING_ARCHIVES}" ]]; then
        default

        # The "ant_src_unpack" function recursively destroys the contents of all
        # paths in "${ANT_BUNDLED_LIBSDIR}". Now, we must not destroy the "${WORK}"
        # path. However, some Java libraries (e.g., Hamcrest) come with JAR files
        # pre-bundled in the "${WORK}" path. We thus homebrew this boolean to
        # recursively remove JAR files rather than all files and paths, prior to
        # calling the "ant_src_unpack" function.
        exparam -b clean_jar_files   && javafix_clean_jar_files
        exparam -b clean_class_files && javafix_clean_class_files
    fi
}

javafix_src_prepare() {
    javafix_src_preamble
    default

    # Deversion files after patching files above but before invoking Ant below.
    [[ -n "${JAVA_SRC_PREPARE_DEVERSION_FILES[@]}" ]] &&
        javafix_deversion_files "${JAVA_SRC_PREPARE_DEVERSION_FILES[@]}"

    # Clean the library directory of all JAR files regardless of whether 
    # "clean_jar_files" is enabled or not. These JAR files will be replaced
    # by symlinks in the call to javafix_prepare_jar_symlinks(), below.
    #
    # Do this here rather than in javafix_src_unpack() to allow exheres to move
    # desired JAR files, prior to their deletion here.
    [[ -d "${JAVA_SRC_LIBRARY_DIR}" ]] &&
        javafix_clean_jar_files "${JAVA_SRC_LIBRARY_DIR}"

    if [[ -n "${JAVA_SRC_PREPARE_JARS[@]}" ]]; then
       [[ -n "${JAVA_SRC_LIBRARY_DIR}" ]] ||
            die_unless_nonfatal "\$JAVA_SRC_LIBRARY_DIR not set; cannot link external JAR files"
        javafix_prepare_jar_symlinks \
            "${JAVA_SRC_LIBRARY_DIR}" "${JAVA_SRC_PREPARE_JARS[@]}"
    fi
}

javafix_src_configure() {
    javafix_src_preamble
}

javafix_src_compile() {
    javafix_src_preamble
}

javafix_src_test() {
    javafix_src_preamble

    if [[ -n "${JAVA_SRC_TEST_JARS[@]}" ]]; then
       [[ -n "${JAVA_SRC_LIBRARY_DIR}" ]] ||
            die_unless_nonfatal "\$JAVA_SRC_LIBRARY_DIR not set; cannot link external JAR files"
        javafix_prepare_jar_symlinks "${JAVA_SRC_LIBRARY_DIR}" \
                     "${JAVA_SRC_TEST_JARS[@]}"
    fi
}

javafix_src_install() {
    javafix_src_preamble
    emagicdocs

    if [[ -n "${JAVA_SRC_INSTALL_JAVADOC_DIR}" ]]; then
        [[ -d "${JAVA_SRC_INSTALL_JAVADOC_DIR}" ]] ||
            die_unless_nonfatal "\"${JAVA_SRC_INSTALL_JAVADOC_DIR}\" not found; cannot install javadoc"
        docinto "html/javadoc"
        dodoc "${JAVA_SRC_INSTALL_JAVADOC_DIR}"/*
    fi

    [[ -n "${JAVA_SRC_INSTALL_JARS[@]}" ]] &&
        javafix_install_jars "${JAVA_SRC_INSTALL_JARS[@]}"
    [[ -n "${JAVA_SRC_INSTALL_JARS_WITH_MANIFESTS[@]}" ]] &&
        javafix_install_jars_with_manifests "${JAVA_SRC_INSTALL_JARS_WITH_MANIFESTS[@]}"
}

javafix_src_preamble() {
    if [[ -n "${JAVA_IS_DISABLING_NETWORK_SANDBOXING}" ]]; then
        ewarn "Disabling network sandboxing..."
        sydboxcmd 'sandunbox/net'
    fi
}

# ....................{ CHECKERS                           }....................
# void javafix_check_jdk(void)
#
# Find the currently selected JDK and ensure the current exheres permits
# building against this JDK.
javafix_check_jdk() {
    # Find the currently selected JDK.
    JAVA_JDK=$(readlink -e "${JAVA_HOME}")
    JAVA_JDK="${JAVA_JDK##*/}"    # basename

    # Grep the currently selected JDK's version. (Oddly, the "javac -version"
    # emits to stderr rather than stdout. Ehhrm?)
    JAVA_JDK_VERSION=$(javac -version 2>&1 | awk '{print $2}')

    # Die if the currently selected JDK is exheres restricted.
    if [[ -n "${JAVA_RESTRICT_JDK_PREFIXES[@]}" ]]; then
        local JAVA_RESTRICT_JDK_PREFIX
        for   JAVA_RESTRICT_JDK_PREFIX in "${JAVA_RESTRICT_JDK_PREFIXES}"; do
            if [[ "${JAVA_JDK}" = ${JAVA_RESTRICT_JDK_PREFIX}* ]]; then
                die_unless_nonfatal "${PNV} refuses to build under ${JAVA_JDK}"
                break
            fi
        done
    fi

    # Warn if the currently selected JDK is GCJ.
    if [[ "${JAVA_JDK}" == gcj* ]]; then
        ewarn "Your currently selected JDK is \"${JAVA_JDK}\". Unfortunately, this JDK"
        ewarn "violates sydbox network sandboxing by attempting to open spurious DNS requests."
        ewarn "Consider installing and selecting an alternative JDK: e.g., \"icedtea6\"."
        JAVA_IS_DISABLING_NETWORK_SANDBOXING=1
    fi
}

# ....................{ CLEANERS                           }....................
# void javafix_clean_jar_files(char *path=${WORK})
#
# Recursively remove all JAR files under the passed path or ${WORK} if no path
# is passed. (Fairly destructive!)
javafix_clean_jar_files() {
    # Do not use "edo rm -f "${WORK}"/**/*.jar" as that tends to glob more
    # files than can be reasonably handled by the shell.
    local cleaning_path="${WORK}"
    if [[ -n "${1}" ]]; then cleaning_path="${1}"; fi
    edo find "${cleaning_path}" -type f -iname '*.jar' \
        "${JAVA_CLEAN_JAR_FILES_PARAMS[@]}" -delete
}

# void javafix_clean_class_files(char *path=${WORK})
#
# Recursively remove all class files under the passed path or ${WORK} if no path
# is passed. (Danger exherbon Danger.)
javafix_clean_class_files() {
    local cleaning_path="${WORK}"
    if [[ -n "${1}" ]]; then cleaning_path="${1}"; fi
    edo find "${cleaning_path}" -type f -iname '*.class' -delete
}

# ....................{ DEVERSIONERS                       }....................
# void javafix_deversion_files(char *filename1, char *filename2, ...)
#
# Deversion the contents of the passed absolute or relative filenames: i.e.,
# remove version suffixes from every matching line in these filenames. Passed
# filenames are typically "build.xml" files, so as to generalize their build
# process to non-versioned JAR files installed on the local machine.
javafix_deversion_files() {
    local deversion_java_file library_jar_spec library_jar_name
    for   deversion_java_file in "${@}"; do
        # Implicitly remove filename version specifiers matching:
        # "-${DSTAMP}.jar", "-${TSTAMP}.jar", or "-${TODAY}.jar". These
        # are Ant properties generated by the "tstamp" task and, when
        # used in JAR filenames, mostly produce badly named JAR files.
        #
        # This should be safe... should.
        edo sed -re 's~-\$\{(DSTAMP|TSTAMP|TODAY)\}\.jar~.jar~' \
                -i "${deversion_java_file}" \

        # Explicitly remove filename version specifiers only for externally
        # symlinked JAR files listed in ${JAVA_SRC_PREPARE_JARS}. Note that
        # elements of this list are jar specifiers and must be converted to a
        # proper absolute path so that the basename of that path, which is the
        # JAR filename, may be matched against.
        #
        # Do not remove version specifiers from other JAR filenames as those
        # filenames may not actually exist. As we can't be sure, we don't.
        if [[ -n "${JAVA_SRC_PREPARE_JARS[@]}" ]]; then
            for library_jar_spec in "${JAVA_SRC_PREPARE_JARS[@]}"; do
                library_jar_name=$(which_installed_jar_file_from_spec "${library_jar_spec}")
                library_jar_name="${library_jar_name##*/}"    # basename
                library_jar_name="${library_jar_name%.jar}"
                edo sed -re "s~${library_jar_name}${JAVA_JAR_VERSION_PATTERN}~${library_jar_name}.jar~" \
                        -i "${deversion_java_file}"
            done
        fi
    done
}

# char *javafix_get_deversioned_jar_basename(char *jar_filename)
#
# Return the deversioned basename of the passed JAR filename.
javafix_get_deversioned_jar_basename() {
    illegal_in_global_scope
    [[ ${#} -eq 1 ]] || die_unless_nonfatal "exactly one argument needed"
    basename "${1/${JAVA_JAR_VERSION_PARAMETER_PATTERN}/.jar}"
}

# ....................{ PREPARERS                          }....................
# void javafix_prepare_jar_symlinks(
#     char *symlink_dir, char *jar_spec1, char *jar_spec2, ...)
#
# Symlink the passed jar specificiers to relative filenames having the same
# basename in the passed absolute or relative path under ${WORK} to the symlink
# directory. If the path already exists, this function kills all JAR files that
# may still exist in it; if it does not, this function creates it. Killing jars
# may be necessary for exheres disabling JAR file cleaning and, in any case,
# never hurts. (They are external dependencies, after all.)
#
# Jar specifiers are compact strings uniquely identifying external JAR file
# dependencies, as described by the "which_installed_jar_file_from_specifier"
# function.
#
# Examples:
#
#      # Symlinks "/usr/share/ecocide/ecocide.jar" into "lib/".
#      javafix_prepare_jar_symlinks("lib" "ecocide")
#
#      # Symlinks "/usr/share/ecocide/4/ecocide.jar" into "lib/".
#      javafix_prepare_jar_symlinks("lib" "ecocide:4")
#
#      # Tries "/usr/share/moa-core/moa-core.jar", which is not found. Then
#      # tries "/usr/share/moa/moa-core.jar", which is found. Finally,
#      # symlinks "/usr/share/moa/moa-core.jar" into "lib/".
#      javafix_prepare_jar_symlinks("lib" "moa-core")
#
#      # Symlinks "/usr/share/ecocide/1080.jar" into "lib/".
#      javafix_prepare_jar_symlinks("lib" "ecocide 1080")
#
#      # Symlinks "/usr/share/ecocide/1.2/1080.jar" into "lib/".
#      javafix_prepare_jar_symlinks("lib" "ecocide:1.2 1080")
#
# For safety, this function dies when the jar to be symlinked does not exist.
javafix_prepare_jar_symlinks() {
    illegal_in_global_scope
    [[ ${#} -ge 2 ]] || die_unless_nonfatal "at least two arguments needed"

    local symlink_dir="${1}"
    [[ -d "${symlink_dir}" ]] || edo install -d "${symlink_dir}"
    shift

    local jar_spec
    for   jar_spec in "${@}"; do
        edo ln -s $(which_installed_jar_file_from_spec "${jar_spec}") \
            "${symlink_dir}"/
    done
}

# ....................{ INSTALLERS                         }....................
# The following convenience functions install all Java libraries produced by
# this exheres into local directories appropriate for this exheres.

# void javafix_install_jars(
#     char *src_jar_filename1, char *src_jar_filename2, ...)
#
# Copy the passed source JAR files to relative filenames having the same
# basename sans version under the installation directory for this exheres: i.e.,
# "/usr/share/${PN}/${SLOT}/". Installed JAR filenames should be versionless to
# permit their usage elsewhere without concern for the specific version each
# represents. This resembles:
#
#     cp "$filename1" "$filename2" ... "${IMAGE}/${JAVA_SRC_INSTALL_JARS_IMAGE_DIR}"
#
# Note that, if this function discovers after installing JAR files that it did
# not install a filename with basename "${PN}.jar", it automatically creates a
# symlink from the first installed JAR file to such a filename. This permits
# exheres depending on this exheres to access the "main" JAR file for this
# exheres under the guaranteed name of "${PN}.jar". This implies that all
# exheres must ensure that the first JAR file passed to this function is their
# "main" JAR file. Example:
#
#     # Let "PN=fastinfoset". Then this copies "dist/FastInfoset.jar" to
#     # "/usr/share/fastinfoset/${SLOT}/FastInfoset.jar" and then symlinks
#     # "/usr/share/fastinfoset/${SLOT}/FastInfoset.jar" to
#     # "/usr/share/fastinfoset/${SLOT}/fastinfoset.jar".
#     javafix_install_jars "dist/FastInfoset.jar"
javafix_install_jars() {
    illegal_in_global_scope
    [[ ${#} -ge 1 ]] || die_unless_nonfatal "at least one argument needed"

    local      jar_dir_target=$(which_installed_jar_dir_for_this_exheres)
    insinto "${jar_dir_target}"

    local jar_file_source \
          jar_file_target jar_file_target_first jar_file_target_basename
    for   jar_file_source in "${@}"; do
        jar_file_target_basename=$(javafix_get_deversioned_jar_basename "${jar_file_source}")
        jar_file_target="${jar_dir_target}/${jar_file_target_basename}"
        echo "cp ${jar_file_source} ${jar_file_target}"
        newins  "${jar_file_source}" "${jar_file_target_basename}"

        if [[ -z "${jar_file_target_first}" ]]; then
            jar_file_target_first="${jar_file_target}"
        fi
    done

    # If the "main" JAR file does not exist, create it by symlinking the first
    # passed JAR file to its filename.
    local jar_file_target_main=$(which_installed_jar_file_for_this_exheres)
    if [[ ! -f "${jar_file_target_main}" ]]; then
        echo "ln -s ${jar_file_target_first} ${jar_file_target_main}"
        dosym      "${jar_file_target_first}" "${jar_file_target_main}"
    fi
}

# void javafix_install_jar_symlinks(
#     char *src_jar_filename1, char *src_jar_filename2, ...)
#
# Symlink the passed source JAR files to relative filenames having the same
# basename sans version under the installation directory for this exheres: i.e.,
# "/usr/share/${PN}/${SLOT}/". Note that the passed files must be installed
# under "${IMAGE}" prior to calling this function. Example:
#
#     # Install "lib/${PNV}.jar" to "/opt/jetty/lib/${PNV}.jar".
#     insinto "/opt/jetty"
#     doins "lib/${PNV}.jar" 
#
#     # Symlink "/opt/jetty/lib/${PNV}.jar" to
#     # "/usr/share/jetty/${SLOT}/${PN}.jar".
#     javafix_install_jar_symlinks "/opt/jetty/lib/${PNV}.jar" 
javafix_install_jar_symlinks() {
    illegal_in_global_scope
    [[ ${#} -ge 1 ]] || die_unless_nonfatal "at least one argument needed"

    local    jar_dir_target=$(which_installed_jar_dir_for_this_exheres)
    dodir "${jar_dir_target}"

    local jar_file_source jar_file_target
    for   jar_file_source in "${@}"; do
        jar_file_target="${jar_dir_target}"/$(javafix_get_deversioned_jar_basename "${jar_file_source}")
        echo "ln -s ${jar_file_source} ${jar_file_target}"
        dosym      "${jar_file_source}" "${jar_file_target}"
    done
}

# void javafix_install_jars_with_manifests(
#     char *jar_filename1, char *manifest_filename1,
#     char *jar_filename2, char *manifest_filename2, ...)
#
# Replace the "META-INF/MANIFEST.MF" file in passed JAR files with the passed
# manifest files for each; then, copy the resultant JAR files to relative
# filenames having the same basename sans version under the installation
# directory for this exheres: usually, "/usr/share/${PN}/${SLOT}/".
javafix_install_jars_with_manifests() {
    illegal_in_global_scope
    [[ ${#} -ge 2 ]] || die_unless_nonfatal "at least two arguments needed"

    # Append each passed JAR file to ${JAR_FILES} for later installation, and
    # replace the passed manifest file for each passed JAR file.
    #
    # Python list comprehensions, eat your pudgy heart out.
    local jar_file manifest_file jar_files=( )
    while [[ -n "${@}" ]]; do
        jar_file="${1}"
        manifest_file="${2}"
        jar_files+=( "${jar_file}" )
        shift 2

        javafix_replace_jar_manifest "${jar_file}" "${manifest_file}"
    done

    javafix_install_jars "${jar_files[@]}"
}

# void javafix_install_jar_as(char *filename1, char *filename2)
#
# Copy absolute "$filename1" to relative "$filename2" under the above directory.
# This is functionally equivalent to:
#
#     cp "$filename1" "${IMAGE}/$javafix_install_jar_dir/$filename2"
javafix_install_jar_as() {
    illegal_in_global_scope
    [[ ${#} -eq 2 ]] || die_unless_nonfatal "exactly two arguments needed"

    # Ignore absolute paths and version specifiers in target JAR filenames.
    local jar_file_source="${1}" jar_file_target="${2}"
    if [[ ${jar_file_target:0:1} = / ]]; then
        jar_file_target="${jar_file_target##*/}"    # basename
    fi
    if [[ "${jar_file_target}" =~ ^(.+)${JAVA_JAR_VERSION_PATTERN}$ ]]; then
        jar_file_target="${BASH_REMATCH[1]}"
    fi

    local      jar_dir_target=$(which_installed_jar_dir_for_this_exheres)
    insinto "${jar_dir_target}"

    echo "cp ${jar_file_source} ${jar_dir_target}/${jar_file_target}"
    newins "${jar_file_source}" "${jar_file_target}"
}

# ....................{ LOCATERS                           }....................
# char *which_installed_jar_dir(char *exheres_name)
#
# Given a passed exheres name (with optional slot appended to that name),
# return the absolute path to the directory into which JAR files were earlier
# installed for that exheres: e.g.,
#
#     # Prints "/usr/share/turkish_dream".
#     echo $(which_installed_jar_dir "turkish_dream")
#     # Prints "/usr/share/british_moors/2.5".
#     echo $(which_installed_jar_dir "british_moors:2.5")
#
# Append the exheres slot to the exheres name as in "DEPENDENCIES": e.g.,
# "${PN}:${SLOT}". A slot need not be specified, of course.
#
# For safety, this function dies when the path does not exist.
which_installed_jar_dir() {
    [[ ${#} -eq 1 ]] || die_unless_nonfatal "exactly one argument needed"

    local    jar_dir=$(which_installed_jar_dir_nonfatal "${@}")
    [[ -d "${jar_dir}" ]] || die_unless_nonfatal "\"${jar_dir}\" not found"
    echo  "${jar_dir}"
}

# char *which_installed_jar_dir_nonfatal(char *exheres_name)
#
# Like "which_installed_jar_dir" but does not die when the path does not exist.
# Avoid calling this function; it is unsafe, and intended only as a utility.
which_installed_jar_dir_nonfatal() {
    illegal_in_global_scope
    [[ ${#} -eq 1 ]] || die_unless_nonfatal "exactly one argument needed"

    # Install JAR files to possibly slotted subdirectories under "/usr/share".
    # Exheres matching this Bash regex are slotted exheres.
    if [[ "${1}" =~ ^(.+):([^:]+)$ ]]
    then echo "/usr/share/${BASH_REMATCH[1]}/${BASH_REMATCH[2]}"
    else echo "/usr/share/${1}"
    fi
}

# char *which_installed_jar_file(char *jar_file)
# --OR--
# char *which_installed_jar_file(char *exheres_name, char *jar_file)
#
# Given a JAR file and optional exheres name and slot, return the absolute path
# to that JAR file as installed on the local system: e.g.,
#
#     # Prints "/usr/share/hamcrest/hamcrest-library.jar".
#     echo $(which_installed_jar_file "hamcrest-library")
#     # Prints "/usr/share/raki-saki/raki-saki-core.jar".
#     echo $(which_installed_jar_file "dist/lib/raki-saki-core.5.22.jar")
#     # Prints "/usr/share/raki-saki/lib/org.turkish.dream.jar".
#     echo $(which_installed_jar_file "raki-saki" "lib/org.turkish.dream-0.1.3.jar")
#     # Prints "/usr/share/raki-saki/8/lib/org.turkish.dream.jar".
#     echo $(which_installed_jar_file "raki-saki:8" "lib/org.turkish.dream-0.1.3.jar")
#
# Append the exheres slot to the exheres name as in "DEPENDENCIES": e.g.,
# "${PN}:${SLOT}". A slot need not be specified, of course. See examples.
#
# This automatically strips version strings from passed JAR filenames as well as
# establishing the expected parent directory. As above, for safety, this
# function dies when the file does not exist.
which_installed_jar_file() {
    local jar_file=$(which_installed_jar_file_nonfatal "${@}")
    javafix_glob_installed_jar_file "${jar_file}"
}

# char *which_installed_jar_file_nonfatal(char *jar_file)
# --OR--
# char *which_installed_jar_file_nonfatal(char *exheres_name, char *jar_file)
#
# Like "which_installed_jar_file" but does not die when the file does not exist.
#
# Avoid calling this function from exheres; it is a utility function intended to
# be called from functions in this exlib.
which_installed_jar_file_nonfatal() {
    illegal_in_global_scope
    [[ ${#} -eq 1 ]] ||
    [[ ${#} -eq 2 ]] || die_unless_nonfatal "one or two arguments needed"
    [[ -n "${1}"  ]] || die_unless_nonfatal "non-null argument needed"

    local jar_name exheres_name

    if [[ ${#} -eq 1 ]]
    then jar_name="${1}"
    else jar_name="${2}"; exheres_name="${1}"
    fi

    # Filename sans absolute path.
    if [[ ${jar_name:0:1} = / ]]; then
        ewarn "\"${jar_name}\" not a relative JAR filename; ignoring path"
        jar_name="${jar_name##*/}"    # basename
    fi

    # Filename sans absolute path and type.
    jar_name="${jar_name%.jar}"

    # Exheres name (including optional slot), if not passed.
    if [[ -z "${exheres_name}" ]]
    then exheres_name="${jar_name}"
    fi

    # Filename sans path, type, and ':'-delimited optional slot.
    jar_name="${jar_name%:*}"

    # Return the absolute path to this file.
    echo "$(which_installed_jar_dir_nonfatal "${exheres_name}")/${jar_name}.jar"
}

# char *javafix_glob_installed_jar_file(char *jar_filename)
#
# Return the absolute path to some JAR file installed on the current system 
# having the passed JAR filename or something resembling the passed JAR
# filename. Specifically, this function performs these heuristics:
#
# * If the passed file is found, return that.
# * If the passed file is not found, then...
#   * ...glob the passed file's path for a filename having the same prefix and
#     filetype, but separated by a version specifier. If at least one file
#     matches, then return the first match. (Ideally, no Java exheres should
#     install versioned JAR files.) Otherwise...
#   * ...glob the path "/usr/share/$(basename ${jar_filename%%-*})/" (that is,
#     a directory whose name is the passed JAR filename up to but not including
#     the first hyphen) for a filename having the same basename. If such a file
#     exists, then return that file. Otherwise...
#   * ...die.
#
# Examples:
#
#     # Suppose the "jakarta-regexp" exheres installed its JAR file to
#     # "/usr/share/jakarta-regexp/jakarta-regexp-1.5.jar" instead of to
#     # "/usr/share/jakarta-regexp/jakarta-regexp.jar". It shouldn't have, of
#     # course; but suppose it did. Then this function prints:
#     #     /usr/share/jakarta-regexp/jakarta-regexp-1.5.jar
#     javafix_glob_installed_jar_file "jakarta-regexp"
#
#     # Suppose the "jakarta-regexp" exheres installed another JAR file to
#     # "/usr/share/jakarta-regexp/jakarta-regexp-core.jar" as is permitted for
#     # exheres installing multiple JAR files. Then this function prints:
#     #     /usr/share/jakarta-regexp/jakarta-regexp-core.jar
#     javafix_glob_installed_jar_file "jakarta-regexp-core"
javafix_glob_installed_jar_file() {
    illegal_in_global_scope
    [[ ${#} -eq 1 ]] || die_unless_nonfatal "exactly one argument needed"

    local jar_file="${1}"
    [[ -f "${jar_file}" ]] && echo "${jar_file}" && return

    # By default, Bash glob expressions return the glob expression itself
    # if the glob matches no files. Of course, this is horrible, since it
    # prevents us from testing whether or not the glob matched.
    #
    # Disable this nonsense.
    shopt -s nullglob

    # If at least one actual file matches the glob, return the first.
    local jar_file_matches=(
        "${jar_file%\.jar}-"${JAVA_VERSION_GLOB}".jar" )
    [[ "${#jar_file_matches[@]}" -ge 1 ]] && \
        echo "${jar_file_matches[0]}" && return

    # If this filename has a hyphen, set the exheres name to the part of the
    # filename preceding the hyphen. If the resultant file exists, return it.
    if [[ "${jar_file}" =~ ^([^-]+)- ]]; then
        local exheres_name="${BASH_REMATCH[1]}"
        local jar_name="${jar_file##*/}"    # basename
        jar_file=$(which_installed_jar_file_nonfatal "${exheres_name}" "${jar_name}")
        [[ -f "${jar_file}" ]] && echo "${jar_file}" && return
    fi

    # No files matched.
    die_unless_nonfatal "\"${jar_file}\" not found"
}

# ....................{ LOCATERS ~~ this exheres           }....................
# char *which_installed_jar_dir_for_this_exheres(void)
#
# Returns the absolute path to the directory into which JAR files will be
# installed for the current exheres:
#
#     # Suppose this exheres is "clathrate_gun:1". Then this function prints:
#     #     /usr/share/clathrate_gun/1
#     echo $(which_installed_jar_dir_for_this_exheres)
#
# This function does not die when the path does not exist, since this function
# is usually called from the "src_install" phase prior to creation of the path.
which_installed_jar_dir_for_this_exheres() {
    [[ ${#} -eq 0 ]] || die_unless_nonfatal "no arguments needed"
    which_installed_jar_dir_nonfatal $(javafix_get_exheres_name_for_this_exheres)
}

# char *which_installed_jar_file_for_this_exheres(void)
#
# Returns the absolute path to the JAR file to be installed for the current
# exheres: e.g.,
#
#     # Suppose this exheres is "clathrate_gun:1". Then this function prints:
#     #     /usr/share/clathrate_gun/1/clathrate_gun.jar
#     echo $(which_installed_jar_file_for_this_exheres)
#
# This function should only be called from exheres installing a JAR file having
# the same name as the exheres name. (Coveniently, this is most of them.)
#
# This function does not die when the file does not exist, since this function
# is usually called from the "src_install" phase prior to creation of the file.
which_installed_jar_file_for_this_exheres() {
    [[ ${#} -eq 0 ]] || die_unless_nonfatal "no arguments needed"
    which_installed_jar_file_nonfatal $(javafix_get_exheres_name_for_this_exheres)
}

# char *javafix_get_exheres_name_for_this_exheres(void)
#
# Return this exheres name optionally suffixed by this exheres slot, if given.
# This is a utility function called by the "*_for_this_exheres" functions above.
javafix_get_exheres_name_for_this_exheres() {
    # Technically, exheres having no slot or a zero slot are unslotted exheres.
    # Nonetheless, this exlib explicitly slots zero slot exheres for forwards
    # compatibility with future releases of those exheres.
    if [[ -z "${SLOT}" ]]
    then echo "${PN}"
    else echo "${PN}:${SLOT}"
    fi
}

# ....................{ LOCATERS ~~ jar specifiers         }....................
# char *which_installed_jar_file_from_spec(char *jar_spec)
#
# Returns the absolute path to the installed JAR file corresponding to the
# passed jar specifier. JAR specificiers are exlib-specific compact strings
# uniquely identifying external JAR files. Because they are compact, JAR
# specifiers are often used to pack JAR file descriptions into Bash arrays and
# pass these descriptions between functions. In their simplest form, JAR
# specifiers are merely paths; in their most complex, whitespace-delimited
# strings. Specifically:
#
# * If an absolute path, the path is returned as is without modification.
# * If a string having no whitespace, the string signifies both the exheres
#   name and optional slot and JAR filename. The slot, if present, is
#   demarcated via a colon. (See below.) Then, the absolute path
#   "/usr/share/${exheres_name}/${slot}" is prepended to the string, the type
#   ".jar" is appended to the string, and the final path is returned. Example:
#
#    # Returns "/usr/share/ecocide/ecocide.jar".
#    which_installed_jar_file_from_spec("ecocide")
#    # Returns "/usr/share/ecocide/4/ecocide.jar".
#    which_installed_jar_file_from_spec("ecocide:4")
#
# * If a string having whitespace, the string is split on the first whitespace
#   in that string. The first half of the resultant split signifies the
#   exheres name and optional slot, while the second half signifies the JAR
#   filename as above. The slot, if present, is demarcated from the exheres
#   name via a colon. (See below.) Then, the absolute path
#   "/usr/share/${exheres_name}/${slot}" is prepended to the string, the type
#   ".jar" is appended to the string, and the final path is returned. Example:
#
#    # Returns "/usr/share/ecocide/1080.jar".
#    which_installed_jar_file_from_spec("ecocide 1080")
#    # Returns "/usr/share/ecocide/1.2/1080.jar".
#    which_installed_jar_file_from_spec("ecocide:1.2 1080")
#
# This function is usually clever enough to suss out the absolute path to
# whatever you pass it. When it doesn't, simply pass the absolute path.
#
# This function dies if no appropriate JAR file can be found.
which_installed_jar_file_from_spec() {
    local jar_file=$(which_installed_jar_file_from_spec_nonfatal "${@}")
    echo $(javafix_glob_installed_jar_file "${jar_file}")
}

# char *which_installed_jar_file_from_spec_nonfatal(char *jar_spec)
#
# Like "which_installed_jar_file_from_spec" but does not die when the file does
# not exist.
#
# Avoid calling this function from exheres; it is a utility function intended to
# be called from functions in this exlib.
which_installed_jar_file_from_spec_nonfatal() {
    illegal_in_global_scope
    [[ ${#} -eq 1 ]] || die_unless_nonfatal "exactly one argument needed"

    local jar_spec="${1}" jar_file

    # If an absolute path, use as is.
    if [[ "${jar_spec:0:1}" = / ]]; then
        jar_file="${jar_spec}"
    # Otherwise, get the absolute path.
    else
        # If split on whitespace, grep the exheres name from JAR filename in
        # the passed jar specifier via Bash regexp matching.
        if [[ "${jar_spec}" =~ ^([^[:space:]]+)[[:space:]]+(.+)$ ]]; then
            jar_file=$(which_installed_jar_file_nonfatal "${BASH_REMATCH[1]}" "${BASH_REMATCH[2]}")
        # Otherwise, the JAR filename is the passed jar specifier.
        else
            jar_file=$(which_installed_jar_file_nonfatal "${jar_spec}" "${jar_spec}")
        fi
    fi

    echo "${jar_file}"
}

# ....................{ MANIFEST.MF                        }....................
# void javafix_replace_jar_manifest(char *jar_filename, char *manifest_filename)
#
# Replace "META-INF/MANIFEST.MF" in the passed JAR filename with the passed
# manifest filename. Also, substitute placeholder variables with their current
# Bash values as performed by the "javafix_rectify_jar_manifest" function.
#
# Exheres usually call this function from "src_install", occasionally overriding
# exheres globals with JAR file-specific locals: e.g.,
#
#     local PV=0.8.1   # ...hides the global ${PV}
#     javafix_replace_jar_manifest "dist/${PN}.jar" "${FILES}/${PN}-MANIFEST.MF"
javafix_replace_jar_manifest() {
    illegal_in_global_scope
    [[ ${#} -eq 2 ]] || die_unless_nonfatal "exactly two arguments needed"

    local      JAR_FILE="${1}"
    local MANIFEST_FILE="${2}"

    # Copy the source to target manifest file, and patch placeholders.
    edo mkdir -p              "${TEMP}/META-INF"
    edo cp "${MANIFEST_FILE}" "${TEMP}/META-INF/MANIFEST.MF"
    javafix_rectify_jar_manifest      "${TEMP}/META-INF/MANIFEST.MF"

    # Move the JAR file to the temporary path having the target manifest,
    # temporarily renaming it for convenience.
    edo mv "${JAR_FILE}" "${TEMP}/temp.jar"

    # All JDKs install a "jar" binary. Most such binaries permit update, but
    # not replacement, of existing JAR file manifest files. That is not what we
    # want; so, unfortunately, we depend on the "zip" binary. It is not
    # guaranteed to be installed. Depend on it, above.
    #
    # "zip" requires we we change directories. *sigh*
    edo pushd "${TEMP}"
    edo zip -q "temp.jar" "META-INF/MANIFEST.MF"

    # Get us home, Commander Gaeta.
    edo popd

    # Move the JAR file back to its original path.
    edo mv "${TEMP}/temp.jar" "${JAR_FILE}"
}

# void javafix_rectify_jar_manifest(char *manifest_filename)
#
# Substitute placeholder variables in the passed manifest file with their
# current values. Recognized placeholders are:
#
# * "__PN__", which will be substituted with ${PN}.
# * "__PV__", which will be substituted with ${PV}.
# * "%bundleName", "%fragmentName", "%pluginName", which will both be
#   substituted with ${BUNDLE_NAME}. If ${BUNDLE_NAME} is not set, defaults to
#   ${PN}. This is O.K.; this variable is usually applied to the "Bundle-Name"
#   manifest key, which, under the OSGi standard, is an optional key for GUI
#   purposes.
# * "%bundleProvider" or "%providerName", which will both be substituted with
#   ${BUNDLE_VENDOR}. If ${BUNDLE_VENDOR} is not set, defaults to "Exherbo!"
#   This is O.K.; this variable is usually applied to the "Bundle-Vendor"
#   manifest key, which, under the OSGi standard, is an optional key.
#
# Placeholder variables prefixed by '%' are specific to the Java OSGi standard.
# Placeholder variables enclosed by '__' are specific to this function, and
# chosen so as to avoid conflicting with existing manifest file text.
#
# Also forcefully replace the value of a "Bundle-Version" manifest key, if
# found, with ${PV}. This is a mandatory OSGi key, which, necessarily, should
# reflect the ${PV} for this exheres. Similarly, replace the contents of strings
# matching 'version="[.[:digit:]]+"' with ${PV}.
#
# Also forcefully delete any lines with manifest keys matching "Name" or
# "SHA1-Digest". These are optional non-OSGi keys, which, when specified, force
# the jar-embedded filename corresponding to the value of "Name" to have an SHA1
# sum evaluating to the value of "SHA1-Digest". Because exheres often apply OSGi
# and non-OSGi manifest files from older versions of the output JAR file that
# exheres installs, the actual SHA1 sums of jar-embedded files almost never
# correspond to the manifest values. (Trust us.)
#
# Exheres usually call this function from "${PN}_src_prepare", often overriding
# exheres globals with JAR file-specific locals: e.g.,
#
#     local PV=3.0.2                   # ...hides the global ${PV}
#     local BUNDLE_NAME="SAT4J Core"   # ...hides the global ${BUNDLE_NAME}
#     javafix_rectify_jar_manifest "${WORK}/build/META-INF/MANIFEST.MF"
#
# !!!!!IMPORTANT!!!!! strings substituted into placeholder variables must not
# contain backtick characters '`', as the sed expressions performing these
# substitutions use that character to delimit themselves. Since this would be a
# strange character for a string to contain, this is generally "safe."
javafix_rectify_jar_manifest() {
    illegal_in_global_scope
    [[ ${#} -eq 1 ]] || die_unless_nonfatal "one argument needed"

    #FIXME leycec: this isn't quite right, but it's close. Continued lines
    #(i.e., long key values continued over several lines) should be temporarily
    #uncontinued prior to performing seding and then recontinued after seding.
    #Then, we should be seding version strings in the "Export-Package" key
    #value (but not the "Import-Package" key value!) with something resembling:
    #   -e "s\`(version=\")[[:digit:].]+\"\`\\1${PV}\"\`g" \

    # Perform the following sed pipeline:
    #
    # {1} Unconditionally convert DOS newlines to Unix newlines. (It happens.)
    # {2} Unconditionally delete whole lines having "bad" keys. Note this also
    #     generates an excess of blank lines, which we later delete. See below.
    #     Also note this deletes the range of all lines between the first "bad"
    #     key of a section and the last "bad" key of the same section; this is
    #     necessary as key values often wrap around to the next line.
    # {3} Unconditionally replace versions with exheres-specific versions.
    # {4} Conditionally replace key values with exheres-specific values.
    # {5} Unconditionally delete consecutive blank lines. Ensure at least one
    #     blank line in a run of blank lines remain, as blank lines in manifest
    #     files are actually syntactically vital: they demarcate sections.
    #
    # What could be simpler? Note that several of these come verbatim from the
    # sed FAQ at http://sed.sourceforge.net/sed1line.txt .
    edo sed -r \
        -e 's/\r$//' \
        -e '/^Name:[[:space:]]/,/^SHA1-Digest:[[:space:]]/d' \
        -e '/^Bundle-ClassPath:[[:space:]]/d' \
        -e "s\`^(Bundle-Version:[[:space:]]).+$\`\\1${PV}\`" \
        -e "s\`^(implementation-version:[[:space:]]).+$\`\\1${PV}\`" \
        -e "s\`^(Build-JDK:[[:space:]]).+$\`\\1${JAVA_JDK_VERSION}\`i" \
        -e "s\`__PN__\`${PN}\`" \
        -e "s\`__PV__\`${PV}\`" \
        -e "s\`%bundleName\`${BUNDLE_NAME:-${PN}}\`" \
        -e "s\`%fragmentName\`${BUNDLE_NAME:-${PN}}\`" \
        -e "s\`%pluginName\`${BUNDLE_NAME:-${PN}}\`" \
        -e "s\`%bundleProvider\`${BUNDLE_VENDOR:-Exherbo!}\`" \
        -e "s\`%providerName\`${BUNDLE_VENDOR:-Exherbo!}\`" \
        -e '/./,/^$/!d' \
        -i "${1}"
}

# ....................{ NSPLUGIN                           }....................
# void register_mozplugin(path_to_installed_plugin, label)
#
# Register an NSAPI-compatible browser plugin with the "mozplugin-java"
# alternatives module. Call this only from src_install, preferably at the end,
# or at least after the plugin's .so file has been installed to ${IMAGE}. The
# first parameter expects the installation path of the plugin's .so file (do
# not prefix it with ${IMAGE}), and the optional second parameter specifies a
# label to append to the end of the plugin's alternatives module entry.
#
# register_mozplugin can be called multiple times if a package provides
# multiple browser plugins, in which case the label parameter should be used to
# distinguish each plugin. For instance, current Sun JDKs/JREs ship two browser
# plugins for x86: the original plugin, and a greatly improved next-generation
# version, aka "plugin2". The label parameter used for the former is "plugin1",
# and for the latter, "plugin2". (On amd64 only the next-generation plugin is
# available, so the label parameter could be omitted.)
register_mozplugin() {
    illegal_in_global_scope
    [[ ${EXHERES_PHASE} == install ]] ||
        die_unless_nonfatal "${FUNCNAME} can only be called from src_install"
    [[ ${#} -ge 1 ]] || die_unless_nonfatal "at least one argument needed"

    local plugin_dir="${1}"
    [[ -d "${IMAGE}${plugin_dir}" ]] ||
        die_unless_nonfatal "\"${IMAGE}${plugin_dir}\" not found"

    local mozilla_plugins_dir="/usr/$(get_libdir)/mozilla/plugins"
    keepdir "${mozilla_plugins_dir}"

    alternatives_for "mozplugin-java" \
        "${PN}-${SLOT}${2:+-${2}}" \
        "${SLOT}" \
        "${mozilla_plugins_dir}/${1##*/}" \
        "${plugin_dir}"
}

#FIXME: Obsolete.
#       local jar_file_current jar_basename_current \
#          jar_dir=$(dirname "${jar_file}") \
#          jar_basename=$(basename "${jar_file}")
#       for jar_file_current in "${jar_dir}"/*; do
#           jar_basename_current=$(javafix_get_deversioned_jar_basename "${jar_file_current}")

#           if [[ ${jar_basename} == ]]; then
#           fi
#       done

#       echo ">>> ${jar_file} not found; globbing..."
#             jar_file_matches=( "${jar_file%\.jar}-"*".jar" )
#       echo ">>> globbed: ${jar_file_matches[@]}"

    # If not found but has a hyphen, grep the exheres name again.
#           if [[ ! -f "${jar_file}" ]] &&
#              [[ "${jar_spec}" =~ ^([^-]+)- ]]; then
#              jar_file=$(which_installed_jar_file_nonfatal "${BASH_REMATCH[1]}" "${jar_spec}")
#           fi

